---
layout: post
title: Kali Linux 渗透测试 (OSCP) 笔记 0x02
date: '2020-10-08 06:26:00'
tags:
- pentest
- kali
- oscp
- hash-import-2023-03-22-16-36
---

## Bash 环境

### 环境变量

使用 `echo` 和 `$` 后面跟环境变量名来显示相应的环境变量：

<!--kg-card-begin: markdown-->

    $ echo $PATH
    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

<!--kg-card-end: markdown-->

通过 `export` 命令来定义环境变量，假如需要扫描一个 IP 但是不想每次输入 IP 地址，可以定义一个 IP 变量：

    $ export b=192.168.1.10
    $ ping -c 2 $b
    PING 192.168.1.10 (192.168.1.10) 56(84) bytes of data.
    64 bytes from 192.168.1.10: icmp_seq=1 ttl=64 time=3.50 ms
    64 bytes from 192.168.1.10: icmp_seq=2 ttl=64 time=0.973 ms
    
    --- 192.168.1.10 ping statistics ---
    2 packets transmitted, 2 received, 0% packet loss, time 10ms
    rtt min/avg/max/mdev = 0.973/2.237/3.501/1.264 ms

`export` 命令定义的变量名在当前 Bash 实例下的所有子进程中都可用。如新打开一个 shell，查看 `$b` 变量：

    $ echo "$$"	# 查看 SHELL 的 PID
    bash: 4433
    $ bash	# 新建 BASH
    
    $ echo "$$"	# 查看当前 SHELL PID
    bash: 5132
    $ echo $b
    192.168.1.10

使用 `env` 命令查看所有环境变量：

    $ env
    SHELL=/bin/bash
    ...
    PWD=/home/kali
    XDG_SESSION_DESKTOP=lightdm-xsession
    LOGNAME=kali
    XDG_SESSION_TYPE=x11
    XAUTHORITY=/home/kali/.Xauthority
    XDG_GREETER_DATA_DIR=/var/lib/lightdm/data/kali
    HOME=/home/kali
    ...
    TERM=xterm-256color
    USER=kali
    ...

### Tab 自动补全

使用 `[Tab]` 键自动补全当前输入：

    $ ls D[TAB]
    Desktop/ Documents/ Downloads/
    $ ls De[TAB]sktop/
    

### Bash 历史记录

使用 `history` 命令查看 bash 历史记录：

    $ history
    1 cat /etc/lsb-release
    2 clear
    3 history

使用 `!` 后面跟数字来执行指定的历史命令：

    $ !1 # 执行编号为 1 的历史命令，即 cat /etc/lsb-release
    cat /etc/lsb-release
    DISTRIB_ID=Kali
    DISTRIB_RELEASE=kali-rolling
    DISTRIB_CODENAME=kali-rolling
    DISTRIB_DESCRIPTION="Kali GNU/Linux Rolling"

使用 `!!` 执行上一个历史命令：

    $ sudo systemctl restart apache2
    
    $ !!
    sudo systemctl restart apache2
    

Bash 命令历史记录默认保存在 `.bash_history` 中，`HISTSIZE` 和 `HISTFILESIZE` 环境变量可以调整当前会话记录历史记录条数和保存在 `.bash_history` 中的历史命令条数，通过修改 `.bashrc` Bash 配置文件来修改。

使用方向键上下来切换上一条或下一条历史记录。使用 `Ctrl+R` 命令进入 _reverse-i-search_ 模式，来搜索指定开头的历史记录，然后通过回车键 `[Return]` 执行，如：

    $ ls
    Desktop Documents Downloads Music Pictures Public Templates Videos
    $ [CTRL-R]l
    (reverse-i-search)`l': ls
    

## [管道和重定向](https://developer.ibm.com/zh/technologies/linux/tutorials/l-lpic1-103-4/)

每个从命令行运行的命令，都存在三个连接到该命令的数据流，用来和外部环境通讯：

<!--kg-card-begin: html-->

|   
Stream Name |   
描述 |
|   
STDIN |   
标准输入流 |
|   
STDOUT |   
标准输出流 |
|   
STDERR |   
标准错误流 |

<!--kg-card-end: html-->

使用管道符 `|` 和重定向符 `< 和 >` 连接不同程序和文件流。

### 重定向到新文件

使用 `>` 操作符，将标准输出重定向到文件：

    $ echo "test"
    test
    $ echo "test" > redirection_test.txt
    
    $ ls
    redirection_test.txt
    $ cat redirection_test.txt
    test

### 重定向到已存在的文件

使用 `>>` 将标准输出追加到已存在的文件后：

    $ echo "hello world" >> redirection_test.txt
    
    $ cat redirection_test.txt
    test
    hello world

### 将文件内容重定向出来

使用 `<` 将文件内容重定向到前面输入的命令，如将 `redirection_test.txt` 文件中的内容重定向到 `wc` 命令，计算文件中字符数：

    $ cat redirection_test.txt
    test
    $ wc -m < redirection_test.txt
    5

### 重定向标准错误流

根据 **POSIX** 标准，_STDIN, STDOUT, STDERR_ 分别用 _0, 1, 2_ 表示，这些数字可以用来从命令行操作相关的数据流，下面例子通过标准错误流来展示这些数字的作用：

    $ ls .
    Desktop Documents Downloads Music Pictures Public Templates Videos
    $ ls ./text
    ls: cannot access './text': No such file or directory
    $ ls ./test 2> error.txt
    
    $ cat error.txt
    ls: cannot access './text': No such file or directory

`error.txt` 中包括了错误信息（由 _STDERR_ 生成），通过 `>` 操作符将错误信息重定向到了 `error.txt` 文件中（2=STDERR）。

### 管道符

使用 `wc` 命令，来展示 `|` 管道符：

    $ cat error.txt
    ls: cannot access './text': No such file or directory
    $ cat error.txt | wc -m	# -m 统计字符串
    54
    $ cat error.txt | wc -m > count.txt
    
    $ cat count.txt
    54

上面例子中，使用 `|` 管道符将 `cat error.txt` 命令的输出重定向到了 `wc -m` 命令的输入中。

## 文字搜索和相关操作

这部分主要熟悉 `grep, sed, cut, awk` 命令。

### [grep](https://linux.die.net/man/1/grep)

`grep` 命令从当前出现的字符中通过给定的表达式搜索结果，并将包含结果的行输出到标准输出（通常是当前终端）。通常配合 `-r` (强调搜索子目录，同 `-d recurse`) 和 `-i` （忽略大小写）：

    $ ls -la /usr/bin | grep zip
    lrwxrwxrwx. 1 root root 5 May 10 2019 bunzip2 -> bzip2
    lrwxrwxrwx. 1 root root 5 May 10 2019 bzcat -> bzip2
    -rwxr-xr-x. 1 root root 38472 May 10 2019 bzip2
    -rwxr-xr-x. 1 root root 17560 May 10 2019 bzip2recover
    ...

### [sed](https://www.gnu.org/software/sed/manual/sed.html)

**sed** 是一个功能强大的流编辑器，也很复杂。一个简单的例子：

    $ echo "I need to try hard" | sed 's/hard/harder/'
    I need to try harder

这个例子中，通过 `sed` 命令将 "I need to try hard" 字符串中的 _hard_ 提换成了 _harder_，然后输出。

### [cut](https://linux.die.net/man/1/cut)

`cut` 命令是一个简单顺手的命令，用来将字符从字符串中提取出来并输出。常用的选项是 `-f`（字段编号）和 `-d`（分隔符）：

    $ echo "I hack binaries,web apps,mobile apps, and just about anything else" | cut -f 2 -d ","
    web apps

从 `/etc/passwd` 中提取所有用户名：

    $ cut -d ":" -f 1 /etc/passwd
    root
    daemon
    bin
    sys
    ...

### [awk](https://www.gnu.org/software/gawk/manual/gawk.html)

`awk` 是一种程序设计语言，应用于各种计算和数据处理任务，很强大也很复杂。一个常用的操作选项是 `-F` 选项（分割字段）和 `print` 命令（输出结果）：

    $ echo "hello::there::friend" | awk -F "::" '{print $1, $3}'
    hello friend

## 在命令行编辑文件

### [nano](https://www.nano-editor.org/docs.php)

Nano 是一个简单易用的文本编辑器，使用 `nano` 命令运行：

    $ nano intro_to_nano.txt

该命令会打开一个编辑窗口。常用操作包括：

- Ctrl + o：将更改写入文件
- Ctrl + k：剪切当前行
- Ctrl + u：将剪切的内容粘贴到当前光标位置
- Ctrl + w：搜索
- Ctrl + x：退出

### vi

_vi_ 是一个强大的文本编辑器，效率很高，学习成本也比较大。使用命令 `vi` 来编辑文件：

    $ vi intro_to_vi.txt

当文件编辑窗口打开后，使用 `i` 命令，启用编辑模式。

当编辑完成后，使用 `Esc` 键退出编辑模式，回到命令模式。在命令模式下，常用操作为：

- `dd` : 删除当前行
- `yy` : 复制当前行
- `p` : 粘贴已复制的内容
- `x` : 删除当前光标处的字符
- `:w` : 保存文件
- `:q!` : 强制退出编辑并放弃保存
- `:wq` : 保存文件并退出

通过以下资料了解更多：

> [https://en.wikibooks.org/wiki/Learning\_the\_vi\_Editor/vi\_Reference](https://en.wikibooks.org/wiki/Learning_the_vi_Editor/vi_Reference)

> [https://www.debian.org/doc/manuals/debian-tutorial/ch-editor.html](https://www.debian.org/doc/manuals/debian-tutorial/ch-editor.html)

## 文件对比

### [comm](https://linux.die.net/man/1/comm)

_comm_ 命令简单对比两文件，输出每行的对比结果。对比结果共三列，分辨代表近第一个文件中的行，两文件中同时存在的行，以及仅在第二个文件中的行。可通过 `-n` 选项，选择显示对比结果。效果如下：

    $ cat scan-a.txt
    192.168.1.1
    192.168.1.2
    $ cat scan-b.txt
    192.168.1.1
    192.168.1.3
    192.168.1.4
    192.168.1.5
    192.168.1.6
    $ comm scan-a.txt scan-b.txt
            192.168.1.1
    192.168.1.2
        192.168.1.3
        192.168.1.4
        192.168.1.5
        192.168.1.6
    $ comm -1 scan-a.txt scan-b.txt # 仅显示 scan-b.txt 文件中的内容
        192.168.1.1
    192.168.1.3
    192.168.1.4
    192.168.1.5
    192.168.1.6
    $ comm -12 scan-a.txt scan-b.txt # 显示两文件中同时存在的行
    192.168.1.1

### [diff](https://linux.die.net/man/1/diff)

_diff_ 命令和 _comm_ 命令差不多，但是支持更多输出选项。两个常用的选项是 `-c` 和 `-u`。

    $ diff -c scan-a.txt scan-b.txt
    *** scan-a.txt 2018-02-07 14:46:21.557861848 -0700
    --- scan-b.txt 2018-02-07 14:46:44.275002421 -0700
    ***************
    ***1,5****
      192.168.1.1
    - 192.168.1.2
      192.168.1.3
      192.168.1.4
      192.168.1.5
    --- 1,5 ----
      192.168.1.1
      192.168.1.3
      192.168.1.4
      192.168.1.5
    + 192.168.1.6
    
    $ diff -u scan-a.txt scan-b.txt
    --- scan-a.txt 2018-02-07 14:46:21.557861848 -0700
    +++ scan-b.txt 2018-02-07 14:46:44.275002421 -0700
    @@ -1,5 +1,5 @@
     192.168.1.1
    -192.168.1.2
     192.168.1.3
     192.168.1.4
     192.168.1.5
    +192.168.1.6

### [vimdiff](http://www.vim.org/)

_vimdiff_ 通过 _vim_ 打开多个文件，不同部分高亮显示。常用快捷键：

- `do` : 从其他窗口获取修改，应用到当前窗口
- `dp` : 将当前窗口中的改变应用到另一个窗口
- `]c` : 跳到下一处修改部分
- `[c` : 跳到上一处
- `Ctrl+w` : 切换到另一个窗口

## 管理进程

Linux 内核通过进程管理多任务。内核掌握每个进程的信息，每个进程拥有一个 PID（Process ID）。

Linux shell 引入 _[jobs](https://en.wikipedia.org/wiki/Job_control_(Unix))_ 这个概念。比如，`cat error.txt | wc -m` 是一个拥有两个进程的管道命令，shell 将其视为一个 job。

### 后台进程（bg）

之前的命令都是运行在前台的（foreground），这意味着在当前命令结束前，不能执行其他命令。我们可以将命令后台执行以便同时执行其他命令。

一个简单方法是在命令后添加 `&` 符号，这表示在命令开始时将其送到后台。例如：

    $ ping -c 400 localhost > ping_results.txt &
    [1] 844

上面命令将给 localhost 发送 400 个 ICMP echo 包，将结果写入 `ping_results.txt`。该命令自动在后台执行。

如果执行命令时忘记添加 `&` 将命令放在后台，可以通过 `Ctrl + c` 结束命令，添加后再执行。另一个方法是使用 `Ctrl + z` 暂停命令，然后使用 `bg` 命令将该进程放置到后台：

    $ ping -c 400 localhost > ping_results.txt
    ^Z
    [1]+ Stopped ping -c 400 localhost > ping_results.txt
    $ bg
    [1]+ ping -c 400 localhost > ping_results.txt &
    $

这时该任务就被放置到了后台执行。需要注意的是有些命令对时间敏感，如果暂停过长时间会导致输出结果异常。如上面的 `ping` 命令，如果在接收返回数据包时暂停了命令，`ping` 就会无法获取到返回包，导致结果不正确。

### 任务管理：jobs 和 fg 命令

使用 `jobs` 和 `fg` 命令可以快速检查 ICMP echo 的状态。

`jobs` 命令可以列举出当前终端会话下运行着的任务，`fg` 命令可以将后台任务放置到前台。

    $ ping -c 400 localhost > ping_results.txt
    ^Z
    [1]+ Stopped ping -c 400 localhost > ping_results.txt
    $ find / -name sbd.exe
    ^Z
    [2]+ Stopped find / -name sbd.exe
    $ jobs
    [1]- Stopped ping -c 400 localhost > ping_results.txt
    [2]+ Stopped find / -name sbd.exe
    $ fg %1
    ping -c 400 localhost > ping_results.txt
    ^C
    $ jobs
    [2]+ Stopped find / -name sbd.exe
    $ fg
    find / -name sbd.exe
    /usr/share/windows-resources/sbd/sbd.exe
    ...

在上面的命令中，`^C` 表示 `Ctrl + c`，用来终止当前进程。`fg` 命令后面的参数 `%1` 表示将任务编号为 1 的命令放到前台执行。有多种方式来表示后台任务，将一个后台任务放置到前台：

- `%n` : 指定任务编号，任务编号由 `jobs` 命令提供。比如 `%1` 或 `%2`
- `%s` : 指定任务开头的命令，比如 `%ping`
- `%+` 或 `%%` : 指当前任务
- `%-` : 指上一个任务

### 任务管理：ps 和 kill

_[ps](http://www.linfo.org/ps.html)_ 命令相比 `jobs` 命令更强大和使用。该命令不止列举出当前终端会话下的进程，而且列出系统进程等。（在 Windows PowerShell 中也存在 `ps` 命令，是 `Get-Process` 的别名）

在渗透测试中，访问主机后的一件事就是检查系统中运行着那些软件，这可以帮助我们评估当前权限、收集附加信息，为后续的操作做准备。

尝试打开 _Leafpad_ 然后使用 `ps` 命令找到进程 ID（[PID](https://en.wikipedia.org/wiki/Process_identifier)）：

    $ ps -ef
    ...
    groot 869 829 1 00:05 pts/0 00:00:00 leafpad
    www-data 973 506 0 00:05 ? 00:00:00 /usr/sbin/apache2 -k start
    www-data 974 506 0 00:05 ? 00:00:00 /usr/sbin/apache2 -k start
    groot 1069 829 0 00:05 pts/0 00:00:00 ps -ef
    ...

`-ef` 选项表示：

- `-e` : 选出所有进程
- `-f` : 显示全部列（UID, PID, PPID，等）

在相当多的进程中找到我们的 _Leafpad_ 程序有些复杂，这时可以将 `-e` 选项替换为 `-C` （通过命令名称选择）选项：

    $ ps -fC leafpad
    UID PID PPID C STIME TTY TIME CMD
    groot 869 829 0 00:05 pts/0 00:00:00 leafpad

上面的结果返回了 _leafpad_ 的 PID。通过查看手册了解 `ps` 命令的更多用法（`man ps`），会发现 `ps` 命令相当于进程管理的瑞士军刀。

如果要结束一个进程，可以通过 `kill` 命令后跟 PID 来实现。比如结束 _leafpad_ 程序：

    $ kill 869
    
    $ ps aux | grep leafpad
    groot 1086 0.0 0.1 12780 1012 pts/0 S+ 00:14 0:00 grep leafpad

这相当于 `kill` 命令给 _Leafpad_ 发送了一个 _SIGTERM_（请求结束进程信号）。

## 文件和命令监控

对文件和命令进行实时监控在渗透测试中非常重要。`tail` 和 `watch` 是两个很有帮助的命令。

### tail

通常用 _[tail](https://linux.die.net/man/1/tail)_ 命令来监控日志文件。比如监控 Apache 日志：

    $ sudo tail -f /var/log/apache2/access.log
    127.0.0.1 - - [12/Oct/2020:01:50:39 -0400] "GET / HTTP/1.1" 200 3380 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Safari/605.1.15"
    127.0.0.1 - - [12/Oct/2020:01:50:39 -0400] "GET /icons/openlogo-75.png HTTP/1.1" 200 6040 "http://127.0.0.1/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Safari/605.1.15"
    127.0.0.1 - - [12/Oct/2020:01:50:39 -0400] "GET /favicon.ico HTTP/1.1" 404 492 "http://127.0.0.1/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Safari/605.1.15"

`-f` 选项可以在目标文件更新时持续更新输出。`-nX` 选项可以输出指定行数（n），代替默认输出 10 行。

### watch

_[watch](https://linux.die.net/man/1/watch)_ 命令可以用指定的时间间隔运行一个（已定义的）命令，默认间隔时间是 2s，可以通过 `-n X` 选项来自定义。比如列出登录用户（`w` 命令），每 5s 刷新：

    $ watch -n 5 w
    Every 5.0s: w kali: Mon Oct 12 02:08:25 2020
    
     02:08:25 up 1 day, 2:50, 1 user, load average: 0.00, 0.04, 0.01
    USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
    root pts/0 :0 23:05 7.00s 3.17s 0.00s watch -n 5 w

使用 `Ctrl + c` 结束命令。

## 下载文件

从命令行下载文件到 Linux 系统中。

### wget

[wget](https://www.gnu.org/software/wget/manual/wget.html) 命令会经常用到，可以通过 HTTP/HTTPS 或 FTP 协议下载文件。使用选项 `-O` 将文件以指定的名称下载到指定位置：

    $ wget -O report_wget.pdf https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
    --2020-10-12 02:13:41-- https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
    Resolving www.offensive-security.com (www.offensive-security.com)... 192.124.249.5
    Connecting to www.offensive-security.com (www.offensive-security.com)|192.124.249.5|:443... connected.
    HTTP request sent, awaiting response... 200 OK
    Length: 27691955 (26M) [application/pdf]
    Saving to: ‘report_wget.pdf’
    
    report_wget.pdf 100%[=================================================>] 26.41M 6.44MB/s in 4.5s
    
    2020-10-12 02:13:48 (5.83 MB/s) - ‘report_wget.pdf’ saved [27691955/27691955]

### curl

[curl](http://www.mit.edu/afs.new/sipb/user/ssen/src/curl-7.11.1/docs/curl.html) &nbsp;可以从服务器获取数据或将数据传输到服务端，该工具支持多种协议，包括 IMAP/S, POP3/S, SCP, SFTP, SMB/S, SMTP/S, TELNET, TFTP 等。在渗透测试中，使用该工具可以下载或上传文件，或者构造更复杂的请求。基本操作为：

    $ curl -o report.pdf https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
      % Total % Received % Xferd Average Speed Time Time Time Current
                                     Dload Upload Total Spent Left Speed
    100 26.4M 100 26.4M 0 0 3795k 0 0:00:07 0:00:07 --:--:-- 5679k

### axel

[axel](http://manpages.ubuntu.com/manpages/xenial/man1/axel.1.html) 是一个下载加速器，通过多连接将文件从 FTP/HTTP 服务器下载下来。该工具有很多特性，较常用的是 `-n` 选项，指定连接数。一个例子（`-a` 显示进度条；`-o` 指定保存文件名）：

    $ axel -a -n 20 -o report_axel.pdf https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
    Initializing download: https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
    File size: 27691955 bytes
    Opening output file report_axel.pdf
    Starting download
    
    Connection 0 finished
    Connection 1 finished
    Connection 3 finished
    Connection 4 finished
    Connection 7 finished
    Connection 2 finished
    Connection 5 finished
    Connection 6 finished
    Connection 8 finished
    Connection 9 finished
    Connection 10 finished
    Connection 12 finished
    Connection 14 finished
    Connection 17 finished
    Connection 18 finished
    Connection 13 finished
    Connection 11 finished
    Connection 15 finished
    Connection 16 finished
    Connection 19 unexpectedly closed
    
    Downloaded 26.4091 Megabyte(s) in 2 second(s). (12716.98 KB/s)

## 自定义 Bash 环境

### 定制 Bash 历史记录

常用的三个自定义 `history` 命令操作和相关返回数据的环境变量是 _HISTCONTROL, HISTIGNORE, HISTTIMEFORMAT_。

_HISTCONTROL_ 参数定义了是否移除重复的命令，或者开头是空格的命令，默认是移除。调整该参数，使其只移除重复命令：

    $ export HISTCONTROL=ignoredups

_HISTIGNORE_ 参数可以定义为过滤常用命令比如 `ls, exit, history, bg` 等：

    $ export HISTIGNORE="$:ls:[bf]g:exit:history"
    
    $ mkdir test
    
    $ cd test
    
    $ ls
    
    $ pwd
    /home/kali/test
    $ ls
    
    $ history
       1 export HISTIGNORE="$:ls:[bf]g:exit:history"
       2 mkdir test
       3 cd test
       4 pwd

_HISTTIMEFORMAT_ 参数可以控制时间戳的显示：

    $ export HISTTIMEFORMART='%F %T '
    
    $ history
       1 2020-10-12 03:22:18 export HISTIGNORE="$:ls:[bf]g:exit:history"
       2 2020-10-12 03:22:25 mkdir test
       3 2020-10-12 03:22:26 cd test
       4 2020-10-12 03:22:29 pwd

`%F` 表示使用（ISO 8601 格式），`%T` 表示 24 小时制。更多格式可以参考 _[strftime](http://man7.org/linux/man-pages/man3/strftime.3.html)_。

### 别名（Alias）

别名是一串可以代替常用命令和参数的字符串，使用别名可以使常用命令更简短。比如给常用的命令 `ls -la` 设置别名：

    $ alias lsa='ls -la'
    
    $ lsa
    total 8
    drwxr-xr-x 2 kali kali 4096 Oct 12 03:22 .
    drwxr-xr-x 15 kali kali 4096 Oct 12 03:22 ..

通过输入 `alias` 不带任何参数来查看已经设置了的别名：

    $ alias
    alias diff='diff --color=auto'
    alias egrep='egrep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias grep='grep --color=auto'
    alias ip='ip --color=auto'
    alias l='ls -CF'
    alias la='ls -A'
    alias ll='ls -l'
    alias ls='ls --color=auto'

设置别名时不检测已使用的关键字冲突问题，这意味着可以使用系统命令来当作其他命令的别名。比如：

    $ alias mkdir='ping -c 1 localhost'
    
    $ mkdir
    PING localhost(localhost (::1)) 56 data bytes
    64 bytes from localhost (::1): icmp_seq=1 ttl=64 time=0.093 ms
    
    --- localhost ping statistics ---
    1 packets transmitted, 1 received, 0% packet loss, time 0ms
    rtt min/avg/max/mdev = 0.093/0.093/0.093/0.000 ms

如果不小心将已存在的命令设置为了别名，解决办法就是退出当前会话，或者使用 `unalias` 命令：

    $ unalias mkdir
    
    $ mkdir
    mkdir: missing operand
    Try 'mkdir --help' for more information.

### 持久化 Bash 配置

Bash 的系统配置在 `/etc/bash.bashrc`。每个用户都可以通过编辑用户根目录下的 `.bashrc 文件`（`~/.bashrc`）自定义自己的配置。

`.bashrc` 文件在每次用户登录时执行，本质上是一个 shell 脚本，所以我们可以插入任何希望执行的命令。下面是 kali 默认的配置：

    $ cat ~/.bashrc
    # ~/.bashrc: executed by bash(1) for non-login shells.
    # see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
    # for examples
    
    # If not running interactively, don't do anything
    case $- in
        *i*) ;;
          *) return;;
    esac
    ...
    # for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
    HISTSIZE=1000
    HISTFILESIZE=2000
    ...
    # enable color support of ls, less and man, and also add handy aliases
    if [-x /usr/bin/dircolors]; then
        test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
        alias ls='ls --color=auto'
        #alias dir='dir --color=auto'
        #alias vdir='vdir --color=auto'
    
        alias grep='grep --color=auto'
        alias fgrep='fgrep --color=auto'
        alias egrep='egrep --color=auto'
        alias diff='diff --color=auto'
        alias ip='ip --color=auto'
    
        export LESS_TERMCAP_mb=$'\E[1;31m' # begin blink
        export LESS_TERMCAP_md=$'\E[1;36m' # begin bold
        export LESS_TERMCAP_me=$'\E[0m' # reset bold/blink
        export LESS_TERMCAP_so=$'\E[01;33m' # begin reverse video
        export LESS_TERMCAP_se=$'\E[0m' # reset reverse video
        export LESS_TERMCAP_us=$'\E[1;32m' # begin underline
        export LESS_TERMCAP_ue=$'\E[0m' # reset underline
    fi

从上面可以找到 `HISTSIZE` 和 `HISTFILESIZE` 环境变量以及 `alias` 别名配置。

